==================================
threadedcomments API Documentation
==================================

.. contents:: Table of Contents
    :backlinks: none

Models
======

*threadedcomments* has two basic models that are included and supported by
default: ``ThreadedComment``, and ``FreeThreadedComment``.  The difference
between these two models is slight.  In essence, every ``ThreadedComment`` 
instance is associated with a user from ``django.contrib.auth.models.User``.
While ``FreeThreadedComment`` has no such user association, it provides a few
other identifying fields instead.

Common Fields
-------------

Below is a listing of all of the fields that are shared by both 
``ThreadedComment`` and ``FreeThreadedComment``.

These first three fields deal with the object with which this comment is
associated:

:``content_type`` [``ForeignKey``]:
    **required** The content type 
    (``django.contrib.contenttypes.models.ContentType``) instance with which 
    this comment is associated.

:``object_id`` [``PositiveIntegerField``]:
    **required** The value of the primary key to which this comment is 
    associated.

:``content_object`` [``GenericForeignKey``]:
    Combines the ``content_type`` and ``object_id`` fields to act as a
    virtual foreign key to the associated object.

The next field is how we build our "threads", or hierarchy:

:``parent`` [``ForeignKey``]:
    A self-referencing foreign key to whom this comment is addressed, 
    being ``None`` if it is a toplevel comment (addressed directly to 
    the original content object).

The following fields deal with keeping track of dates of some events on 
this comment:

:``date_submitted`` [``DateTimeField``]:
    The date and time that this comment was saved for the first time.

:``date_modified`` [``DateTimeField``]:
    The most recent date and time that this comment was saved.

:``date_approved`` [``DateTimeField``]:
    The date and time that this comment set as ``is_approved=True``.

The following fields deal with the actual content of the comment itself:

:``comment`` [``TextField``]:
    **required** The content of the comment.

:``markup`` [``IntegerField``]:
    **required** The format of the comment.  Values may be ``MARKDOWN``, 
    ``TEXTILE``, ``REST``, ``PLAINTEXT``.  This can be used for display
    purposes when deciding how to format the comment for viewing.

The following fields have to do with the status of the comment.  Combined,
they describe whether the comment should be viewable or not:

:``is_public`` [``BooleanField``]:
    **required** This field defaults to ``True``, but will bet set to 
    ``False`` if any of the moderation checks in an associated ``Moderator`` 
    fail.

:``is_approved`` [``BooleanField``]:
    **required** This field defaults to ``False``, and it acts as an 
    administrative override.  It allows administrators to manually "whitelist"
    comments which fail a moderation test resulting in ``is_public``
    being set to ``False``.

The following field is extra metadata that may be generally useful:

:``ip_address`` [``IPAddressField``]:
    This field stores the IP address of the computer that is submits the
    comment.

``ThreadedComment``
-------------------

``ThreadedComment`` is useful for allowing registered users to comment. It is
for this reason that there is a required foreign key to ``User``.

:``user`` [``ForeignKey``]:
    Associates this comment with a particular user from 
    ``django.contrib.auth.models.User``.


``FreeThreadedComment``
-----------------------

``FreeThreadedComment`` is better suited for allowing just about anyone to
post comments on an item.  Instead of being associated with a particular user,
instead it asks for some additional information like name and e-mail.

:``name`` [``CharField``]:
    **required** The name of the person leaving the comment.

:``website`` [``URLField``]:
    If the person leaving the comment runs or is affiliated with a website,
    this is where that information would be stored.

:``email`` [``EmailField``]:
    An e-mail address where the person leaving the comment can be reached.

Custom Managers
===============

Since it's not a feature of most databases to store hierarchical information,
some methods are needed to be able to access that hierarchical information in a
meaningful way.  Also, since these comment objects can attach to any object,
some convenience methods are helpful to query for and to create comments.  
These types of methods do not belong on the model itself, but rather on the 
``Manager``.

Common Methods
--------------

:``get_tree(content_object)``:
    Runs a depth-first search on all of the comments attached to the given
    content object.  It then annotates a ``depth`` field which is an integer 
    representing how many nodes away it is from the root node (the content
    object itself).  It also orders the comments appropriately into threads.

:``create_for_object(content_object, **kwargs)``:
    Wraps the ``create`` method, and automatically fills out ``content_type``
    and ``object_id`` fields based on those given by the content object.

:``get_or_create_for_object(content_object, **kwargs)``:
    Wraps the ``get_or_create`` method, and automatically fills out 
    ``content_type`` and ``object_id`` fields based on those given by the 
    content object.

:``get_for_object(content_object, **kwargs)``:
    Wraps the ``get`` method, and automatically fills out ``content_type``
    and ``object_id`` fields based on those given by the content object.

:``all_for_object(content_object, **kwargs)``:
    Prepopulates a QuerySet with all comments related to the given 
    ``content_object``.


``ThreadedCommentManager``
--------------------------

This manager simply adds all of the aformentioned common methods onto the 
default manager.

It can be used by using the ``objects`` property on either ``ThreadedComment`` 
or ``FreeThreadedComment``.  An example would be::

    >>> FreeThreadedComment.objects.all()
    [<FreeThreadedComment: This is a test.>, <FreeThreadedComment: spam>]

``PublicThreadedCommentManager``
--------------------------------

This manager adds all of the aformentioned common methods onto the default
manager, and then restricts all results to either be ``is_public = True`` or
(by way of administrative override) ``is_approved = True``.

It can be used by using the ``public`` property on either ``ThreadedComment`` 
or ``FreeThreadedComment``.  An example would be::

    >>> FreeThreadedComment.public.all()
    [<FreeThreadedComment: This is a test.>]

Moderation
==========

Moderation is how you are able to assign custom functionality to comments.  
Almost all moderation settings take place by registering manager objects in 
lieu of Django settings.  This means that you may choose different options for comments on different pages, etc.

The design of this moderation system is largely inspired by `James Bennett`_'s
excellent comment_utils_ appplication--in fact, it provides compatibility with
a good portion of the options in comment_utils_' managers.  The implementation, however, is almost entirely dissimilar and much more simplistic.

.. _`James Bennett`: http://www.b-list.org/
.. _comment_utils: http://code.google.com/p/django-comment-utils/

Customization can happen in one of two ways:

1. Keyword Arguments

2. Registration of a ``ThreadedCommentManager``

Note that the keyword arguments are the exact same as the properties on the
``ThreadedCommentManager``, so learning about one implies learning about the
other.

Manager Properties (Or Keyword Arguments)
-----------------------------------------

:``akismet``:
    Set this to either ``True`` or ``False``.  If ``True``, it will check
    Akismet_ to see if it believes the comment to be spam.  If it does, it will
    set ``is_public = False`` before saving.

:``auto_close_field``:
    A string representation of a field name on a model.  It must refer to a 
    ``DateField`` or a ``DateTimeField``.  Combined with ``close_after``, this 
    can disallow comments after a certain number of days has passed.


:``close_after``:
    An integer representing the number of days after the specified 
    ``auto_close_field`` before comments will no longer be accepted.

:``enable_field``:
    A string representation of a field name on a model.  It should refer to a
    ``BooleanField``.  If that field evaluates to ``False`` on a comment's
    ``content_object`` model instance, then the comment will be deleted
    immediately.

:``email_notification``:
    A boolean representing whether or not e-mail notifications should be sent
    out to each manager listed in Django's settings module.  ``True`` means 
    that e-mails will be sent upon each new comment, and ``False`` means that
    they will not.

    If this is set to ``True``, it will render the template in 
    "threadedcomments/comment_notification_email.txt" with the "comment" (the
    comment instance) as context.  There is a default template available for
    this purpose, but you may want to create your own and override it.

:``max_comment_length``:
    The maximum length of a comment, in characters.  Defaults to 
    ``settings.DEFAULT_MAX_COMMENT_LENGTH``.  If a comment goes beyond this 
    length, the manager will set ``is_public = False`` before saving.

:``allowed_markup``:
    A list of which markup types this manager will allow.  If a different
    markup is submitted, the manager will set ``is_public = False`` before
    saving.

    This list can be comprised of zero or more of the following imported 
    constants::
        
        from threadedcomments.models import MARKDOWN, TEXTILE, REST, PLAINTEXT

:max_depth:
    The maximum "depth" of a comment.  That is, it will take no more than 
    max_depth parent relationship traversals to hit a comment with no parent.
    Defaults to ``settings.DEFAULT_MAX_COMMENT_DEPTH``.  If a comment goes 
    beyond this depth, the manager will set ``is_public = False`` before 
    saving.

.. _Akismet: http://akismet.com/

Model-Manager Registration
--------------------------

To register a manager with a model, first the moderator must be imported::

    from threadedcomments.moderation import moderator

Then, the moderator has ``register`` and ``unregister`` functions.

:``register(model, [manager=None, **kwargs])``:
    Registers a model class with a manager or with the aformentioned keyword
    arguments.

:``unregister(model)``:
    Unregisters the manager that's currently associated with the given model.

Examples
--------

Both of the following examples will assume that a "BlogPost" model exists::

    class BlogPost(models.Model):
        title = models.CharField(max_length=128)
        body = models.TextField()
        allows_comments = models.BooleanField(default = True)

1. Using a Manager::

    from threadedcomments.moderation import moderator, ThreadedCommentManager

    class BlogPostManager(ThreadedCommentManager):
        akismet = True
        enable_field = 'allows_comments'

    moderator.register(BlogPost, manager=BlogPostManager)
    

2. Using Keyword Arguments::

    from threadedcomments.moderation import moderator

    moderator.register(BlogPost, akismet=True, enable_field='allows_comments')

Template Helpers
================

While it's possible to import the comment models and use them to query for the
appropriate comments, sometimes it's easier to do some of that manipulation
in the template.  There are several tags and filters which will help to begin
using *threadedcomments*.

To use any of these tags or filters, first make sure to have 'threadedcomments'
listed in your ``INSTALLED_APPS``, and then include the following in your
template::

    {% load threadedcommentstags %}

After "threadedcommentstags" has been loaded, all of the following become
available.

Tags
----

:``{% get_comment_url OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent comment.

:``{% get_comment_url_json OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent comment, 
    which will respond with JSON (useful for AJAX).

:``{% get_comment_url_xml OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent comment, 
    which will respond with XML (useful for AJAX).

:``{% get_free_comment_url OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent free 
    comment.

:``{% get_free_comment_url_json OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent free 
    comment, which will respond with JSON (useful for AJAX).

:``{% get_free_comment_url_xml OBJECT [PARENT=None] %}``:
    Gets the URL to post to for the given object and optional parent free 
    comment, which will respond with XML (useful for AJAX).

:``{% get_comment_count for OBJECT as CONTEXT_VAR %}``:
    Calls ``ThreadedComment.public.all_for_object(OBJECT).count()`` and places 
    the result into the specified context variable.

:``{% get_free_comment_count for OBJECT as CONTEXT_VAR %}``:
    Calls ``FreeThreadedComment.public.all_for_object(OBJECT).count()`` and 
    places the result into the specified context variable.

:``{% auto_transform_markup COMMENT [as CONTEXT_VAR] %}``:
    Inspects the given comment and its markup, and either outputs it using the
    correct markup processor, or if a context variable is specified, outputs
    it into the context for further use.

:``{% get_threaded_comment_tree for OBJECT as CONTEXT_VAR %}``:
    Calls ``ThreadedComment.public.get_tree(OBJECT)`` and places the result 
    into the specified context variable.

:``{% get_free_threaded_comment_tree for OBJECT as CONTEXT_VAR %}``:
    Calls ``FreeThreadedComment.public.get_tree(OBJECT)`` and places the result 
    into the specified context variable.


Filters
-------

:oneline:
    Gets rid of all newlines and spaces in-between tags.  This is useful for
    calling when passing, for example, a form to javascript.  You could use it
    like so::

        <script type="text/javascript">
            var form_html_fragment = '{{ form.as_ul|oneline }}';
        </script>

    Now you could use that ``form_html_fragment`` Javascript variable to 
    dynamically add or remove comment forms to the page.

Views
=====

There are three basic view types included with threadedcomments: **create**, 
**edit**, and **delete**.  The following are the URL names and what inputs they 
take.

**Create**
----------

:``tc_comment``:

    :``content_type``:
        The content type of the model to attach to.

    :``object_id``:
        The primary key of the model to attach to.

:``tc_comment_parent``:

    :``content_type``:
        The content type of the model to attach to.

    :``object_id``:
        The primary key of the model to attach to.

    :``parent_id``:
        The primary key of the parent comment to which this comment is a
        response.

:``tc_comment_ajax``:

    :``content_type``:
        The content type of the model to attach to.

    :``object_id``:
        The primary key of the model to attach to.

    :``ajax``:
        'json' or 'xml', depending on the response type that is wanted.

:``tc_comment_parent_ajax``:

    :``content_type``:
        The content type of the model to attach to.

    :``object_id``:
        The primary key of the model to attach to.

    :``parent_id``:
        The primary key of the parent comment to which this comment is a
        response.

    :``ajax``:
        'json' or 'xml', depending on the response type that is wanted.

:``tc_free_comment``:
    The same as ``tc_comment``, only it deals with ``FreeThreadedComment`` 
    model objects instead of ``ThreadedComment`` objects.

:``tc_free_comment_parent``:
    The same as ``tc_comment_parent``, only it deals with 
    ``FreeThreadedComment`` model objects instead of ``ThreadedComment`` 
    objects.

:``tc_free_comment_ajax``:
    The same as ``tc_comment_ajax``, only it deals with ``FreeThreadedComment`` 
    model objects instead of ``ThreadedComment`` objects.

:``tc_free_comment_parent_ajax``:
    The same as ``tc_comment_parent_ajax``, only it deals with 
    ``FreeThreadedComment`` model objects instead of ``ThreadedComment`` 
    objects.

**Edit**
--------

:``tc_comment_edit``:
    
    :``edit_id``:
        The primary key of the comment that should be edited.

:``tc_comment_edit_ajax``:

    :``edit_id``:
        The primary key of the comment that should be edited.

    :``ajax``:
        'json' or 'xml', depending on the response type that is wanted.

:``tc_free_comment_edit``:
    The same as ``tc_comment_edit``, only it deals with ``FreeThreadedComment``
    model objects instead of ``ThreadedComment`` objects.

:``tc_free_comment_edit_ajax``:
    The same as ``tc_comment_edit_ajax``, only it deals with 
    ``FreeThreadedComment`` model objects instead of ``ThreadedComment`` 
    objects.

**Delete**
----------

:``tc_comment_delete``:

    :``object_id``:
        The primary key of the ``ThreadedComment`` to delete.

:``tc_free_comment_delete``:

    :``object_id``:
        The primary key of the ``FreeThreadedComment`` to delete.

Previewing
----------

If the key 'preview' is inserted into any of the following views, a preview
page ('threadedcomments/preview_comment.html') will be shown:

* ``tc_comment``

* ``tc_comment_parent``

* ``tc_comment_edit``

* ``tc_free_comment``

* ``tc_free_comment_parent``

* ``tc_free_comment_edit``

The context will be:

:next:
    The page to which the user should be redirected after successfully posting
    a comment.  This is usually to be used in a hidden input field in a form
    that tells the view where to go next.

:form:
    Either a ``FreeThreadedCommentForm`` or a ``ThreadedCommentForm``, 
    depending on the type of view.

:comment:
    If the parameters in POST validate correctly with the appropriate form, the
    unsaved comment will be passed in through this variable.

If a GET request is sent to the **Delete** views, a confirmation/preview page
('threadedcomments/confirm_delete.html') will be shown with context:

:comment:
    The comment object to be deleted.

:is_free_threaded_comment:
    True if comment to be deleted is a ``FreeThreadedComment``, and False
    otherwise.

:is_threaded_comment:
    True if comment to be deleted is a ``ThreadedComment``, and False 
    otherwise.

:next:
    The page to which the user should be redirected after successfully deleting
    a comment.  This is usually to be used in a hidden input field in a form
    that tells the view where to go next.

Redirection
-----------

After a comment is posted, choosing where to go next happens in this order:

1. If there exists a ``next`` variable in the POST data, it will redirect 
   there.

2. If there exists a ``next`` variable in the GET data, it will redirect there.

3. If ``HTTP_REFERER`` exists in the request's META information, it will 
   redirect there--as long as it doesn't create an infinite loop.

4. It will raise an ``Http404``.

AJAX
----

*threadedcomments* provides a very basic AJAX implementation.  Upon POSTing to
the view, it will return a JSON or an XML (as requested by URL) representation 
of the object just committed.  It's up to you to dynamically
insert its content into the comment thread.

Errors
------

If a view encounters an error (form validation being the most common case), 
then depending on the type of comment, one of several things will happen.  If
it's a ``FreeThreadedComment``, then any validation errors will be stored in 
the session under the name ``threadedcomment_errors``.

If it's a ``ThreadedComment``, then any validation errors are added to the
user's ``message_set``.  Read the documentation on messages_ to determine how
you would like to query for and display this error information.

.. _messages: http://www.djangoproject.com/documentation/authentication/#messages

.. tip::

    When using ``FreeThreadedComment`` and after a comment is successfully
    saved, the successful ``name``, ``website``, and ``email`` fields will be
    placed into the session under the name ``successful_data``.  To use this
    data for the next time a user visits the website, simply populate the
    initial data for a form with the ``successful_data`` dict.

    For example::

        successful_data = request.session.get('successful_data', {})
        form = FreeThreadedCommentForm(initial = successful_data)

    Now that form will have the user's simple data prepopulated.  It's that
    easy!

Forms
=====

*threadedcomments* provides two basic forms that you can use and/or subclass
to suit your needs: ``ThreadedCommentForm``, and ``FreeThreadedCommentForm``.

``ThreadedCommentForm``
-----------------------

Simply includes two fields: comment, and markup.

:comment:
    **required** The content of the comment.

:markup:
    **required** The type of markup that the comment is using.  This may be 
    easily overridden in a subclass to become a ``HiddenInput``, if the user is 
    not to be given a choice of markup options.

``FreeThreadedCommentForm``
---------------------------

Includes a few fields: comment, name, website, email, and markup.

:comment:
    **required** The content of the comment.

:name:
    **required** The name of the person 

:website:
    A website for the commenter, if he or she has one to list.

:email:
    An e-mail address where the person leaving the comment can be reached.

:markup:
    **required** The type of markup that the comment is using.  This may be 
    esaily overridden in a subclass to become a ``HiddenInput``, if the user is 
    not to be given a choice of markup options.

Settings
========

Most of the configuration will be done via the use of the Moderation_ features
of *threadedcomments* itself, but there are a few settings that you might want 
or need to apply globally in the settings file.

:``AKISMET_API_KEY``:
    Your API key for Akismet.  This will only be needed if you enable Akismet
    moderation of comments on one or more of your models.

:``DEFAULT_MAX_COMMENT_LENGTH = 1000``:
    The default max_length that the comment forms should validate against
    if an override isn't specified in per-model moderation.  If this isn't
    specified, then a default DEFAULT_MAX_COMMENT_LENGTH of 1000 is used.

:``DEFAULT_MAX_COMMENT_DEPTH = 8``:
    The default max_depth that the moderation should validate against if it
    isn't explicitly defined in the moderator.  Keep in mind that if no 
    moderator is registered against a model, this default depth will not be
    adhered to either.

More
====

This is as good as it gets for now.  Until more documentation is posted, check 
out `Tutorial 1`_.  Beyond that, there's fairly extensive in-line 
documentation, so you can `browse the source code`_.  If you're the kind of
person who likes to scan doctests, you can check the tests out here_.

.. _`Tutorial 1`: http://api.rst2a.com/1.0/rst2/html?uri=http%3A//django-threadedcomments.googlecode.com/svn/trunk/docs/tutorial.txt&style=zope
.. _`browse the source code`: http://django-threadedcomments.googlecode.com/svn/trunk/
.. _here: http://django-threadedcomments.googlecode.com/svn/trunk/threadedcomments/tests.py